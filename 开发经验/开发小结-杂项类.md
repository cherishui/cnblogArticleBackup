在进行会议讨论(需求讨论、方案论证等)时，就讨论的问题，陈述的中心思路是讲解问题的背景、问题的现状、问题的困难点，而不是讲述自己对该问题心中默认的结论，我们讨论的是问题，而不是问题提出者的结论。
   
* 看书的时候，带着问题和自己预期的答案去在书中查找对应的知识点，或印证，或加强，或反思。对于好的东西，我们不光要学习，而且要把它内化为自己的东西。我们要学习别人的先进经验，办事方法，但在运用中要实事求是，具体问题具体分析。


* 工作用到的IDE，最多只能打开两个，在一个IDE中完成一个任务后，如果没有其他的任务，要关闭它。防止在太多IDE中切换，让工作心思在不同IDE之间切换，就像进程调度一样，切换调度的成本很高，要适应一段时间才能进入心流模式。

* 在通过截图加文字的方式来相互沟通的时候，截图和对应的说明解释文字，要放在一条信息中，这样可以保证信息的完整性。

* 小结处理问题的思考逻辑：以"获取CPUId、操作系统所在磁盘分区信息"为例子，在刚开始时，我犯了一个错误。具体表现为，没有将注意力关注于问题域，而是在网上大目标的搜索获取磁盘信息做法，在搜索到的这些通用做法中，不仅会有需要的内容，其中也会夹杂很多不需要的内容。面对这些内容，本着多学一点是一点的原始心态，开始照葫芦画瓢的学习，但是做到后面，越发觉得距离最开始的问题目标越来越远。感觉，就算把整个知识点全部吃透再解决这个问题上，是杀鸡用牛刀。虽说最终还是完成了目标，但从效率上，还有优化的空间。

反思下，以后在针对问题进行搜索时，要先定义问题并且掌握一些基本的背景基础知识。然后，针对待解决的问题，只搜索关联度极高的网页来进行验证，在写测试代码时，不要掺杂与待解决问题无关的代码，保证关注度统一性。
    

<管理沟通与非物质激励>:
1. 透彻理解他人的思想
2. 准确表达你的主张
3. 说服他人接收你的主张
4. 让他人按你的主张行动    整体流程按照案例讨论+小组互动，来讲解"管理沟通与非物质激励"
    
    
个人总结
在撰写总结的时候，标题和内容要相互一致.

删除Dll时提示被占用
在 Windows 下面删除dll时，提示被系统使用，无法删除。较好的思考路径是：
	1. 找到该 dll 被哪个进程占用？
	   Windows下可以使用 tasklist /m XXX.dll 来找
	2. 在任务管理器中，暂时中止该进程（如果是窗口管理器占用，那么中止后，任务栏会消失）
	3. 通过 dos 命令来删除文件和文件夹（删除文件使用 del， 删除空文件夹使用 rd）

针对需要动态申请空间的，已知空间大小，可以使用 
    string strBuf(nReqSize, ' '); char* pReqBuf = (char*)strBuf.c_str();
    
    	77. template <uint32_t N>
	using String = char[N];
	
	
	使用时：
	using DefaultAppId = String<32>;
	
	
在工程实践中，使用do...while(false),可以用break的方式实现类似goto的功能，用于简化多级判断时代码的嵌套

```
do{

	if (condition1)
		break;
	
	if (condition2)
		break;
	
}while(0)
```
	
	
在一系列计算的中间过程，只要有一处临时变量在计算过程中，可能超过相关数据类型能够表达的最大范围，那么最终结果就很可能会出错,这种错误很难发现，要满足特定的场景才会发现，在后续涉及到较大数量的计算时，一定要注意。
	
	
* VS发现现有工程目录结构丢失了，显示的是所有文件，可以 点击 项目-->显示所有文件-->然后把 WT.sdf 文件删掉，关闭VS重新打开VS，一般来说，工程的目录结构就会恢复正常了。
* 利用静态代码检查工具`cppcheck`,`cpplint`来辅助检查你的代码。针对资源泄露的问题，注意相关资源申请和释放函数的配对使用
* 利用动态代码检查工具[VLD](https://archive.codeplex.com/?p=vld),[Application Verifier](https://www.microsoft.com/en-us/download/details.aspx?id=20028),


## SVN操作相关 ##

* 在SVN中修改文件名字的规范流程：
   1. 先把该文件从工程中排除掉
   2. 利用svn自身的Rename功能对文件进行重命名
   3. 然后将改名后的文件重新加入到VS工程中去

* 在工程中移动文件的标准流程：
1. 从svn中，将想要移动的文件通过鼠标右键选中并且移动，在目的目录选择拷贝到这里
2. 从VS项目的文件里面中，将此文件删除
3. 然后在VS项目的目的目录中，将此文件重新添加进去

* 在进行svn update的时候，文件正在被编译器占用，此时svn会更新失败，整个项目目录的svn状态不正确，此时可以通过如下方法来解决：
       
	1. svn是采用sqlite3来管理数据的，因此需要下载 sqlite3 ，并将可执行文件路径添加到系统的环境变量中
	2. 进入到 .svn的同级目录，然后执行 
	3. sqlite3 .svn/wc.db "select * from work_queue"   ---> 看到很多记录
	   sqlite3 .svn/wc.db "delete from work_queue"     ---> 删除这些更新失败的记录
	   sqlite3 .svn/wc.db "select * from work_queue"   ---> 确认是否删除完毕
	4. 在此运行 svn 的 clean up

经过如上操作，就能清除更新失败的文件，再重新update一下。

* 查看当前工程的SVN版本号，有两种方法：
1. 查看项目目录的右键属性
2. 查看项目修订记录中的记录，当前标记为黑色的为当前项目的版本号

* 查看SVN的对比测试，可以右键同时多选多个文件来对比，这样比单独每次打开单个的效率提高，在涉及比较多的，同一类型的修改时，效率特别高
配合 ctrl+N，查看下一个不同处，ctrl+P，查看上一个不同处，ctrl+W，关闭当前页面，味道更佳。

## 调试经验 ##

* 在需要查看数据发送内容，而又不想通过断点来中断执行流程，可以通过 VS 的 条件断点 配合特定的条件，在调试输出窗口中查看收发内容。

* 找内存泄漏：根据vld输出的信息，找到泄露内存的具体字节数和内存分配序号，然后在 dbgheap.c 文件中的 391 行出 打上条件断点，通过申请的具体字节数来大致定位是哪一个文件上申请了内容，可以大致定位内存泄漏的源头。
 
* 描述类与类，窗体与窗体之间的相互交互的关系，最好用序列图来描述。流程图中异步处理，可通过带箭头的虚线来表示异步响应的流程。

* 永远不要混合Tab键和Space键。 VS设置，将TAB键转换为4个空格				
* 在程序中，全角和半角英文混用，容易造成显示不一致，在设计的时候要注意。
 
* 在工程实践中，多线程开始初始化之前，对整个工程中所涉及到的单例按照前后的逻辑顺序，完成手动的初始化，这可避免首次调用时的不确定性，简单明确。


* 当一个条件判断（if，while）比较复杂，并且是隐含有一定的业务背景知识的，一定要写好注释，不仅是给自己方便，也是给其他人方便.

* JIRA单处理流程：
	Bug：点击解决，自动就会把JIRA单转给下一个人，如果JIRA单没转，则需要手动去转。
	需求类：到我这里，是需求状态，开发完后，将其转为开发审核状态。在这里，还要手动设置一下转给对应的人员。JIRA在处理需求上面，没有做到我切换完状态后，自动转换人员。

* 从接口中返回const char*指针给外部的string变量，所对应的一块内存是如何响应外部变化的？实际上是调用 `string::operator=(const _Elem* _Ptr)` 赋值构造函数来完成对应地址内容的拷贝的.
* 提示：在VS调试，无法进入到stl的内部函数中去，因为用到 破解的VS助手，把VS助手给禁用掉，重新启动VS,就可以调试进入stl内部。

* 较好的API设计模板
   // 返回值代表查询成功还是失败，字符串入参由const char*来保护引入，出参由引用来引出,结尾加上const，
   	  表面该函数体内部不会对已有成员变量进行修改
   bool GetJyStockFromCache(const char* pCode, vector<CJyStock>& vStock) const;

* 发布给别人的软件，一定要先在自己虚拟机上面跑一次，防止一些软件依赖的dll在用户机器上没有，启动时爆出“未找到 mfc100.dll”的问题。多在自己本地测试下，确保在各种情况下正确后，再交付给用户。

* 二进制兼容性指的是在升级库文件时，不必重新编译使用了这个库的可执行文件或者其他库文件,程序的功能不被破坏。

* 在Windows上，比如Visual C++编译的时候要选择Debug或者Release模式，而且Debug模式编译出来的library通常不能在Release binary中使用，反之亦然。这是因为在这两种模式下的CRT二进制不兼容，主要是内存分配方面的，Debug有自己的堆。
在linux下，编译时涉及到调试的选项为 -g：增加调试信息 -DDEBUG:定义DEBUG宏  ，发布时，一般 一般加上 -O2 或者 -O3 ，然后 利用 strip，去掉调试信息
从这上面来看，linux下的库是不区分Debug模式和Release模式，只不过是运行效率的区别吧了。
使用 libstdc++ 库的 DebugMode，只需要增加编译选项 -D_GLIBCXX_DEBUG 即可

* iostream： cout << a << b << endl; 是两次函数调用,两次调用中间可能被打断进行上下文切换，造成输出内容不连续,是线程不安全的。fprintf(stdout, "%s %d", a, b); 是一次函数调用，而且线程安全

* 解决C++二进制兼容性 

避免使用 虚函数作为库的接口,因为这么做会给保持二进制兼容性带来很大麻烦,更深一步，
本质在于 C++以 vtable[offset]方式实现虚函数调用，offset又是根据虚函数声明的位置隐式确定。

1. 可以使用 静态链接
2. 用 pimpl 技法： 在头文件中只暴露 non-virtual 接口，并且class的大小固定为 sizeof(Impl*),这样可以随意更新库文件而不影响可执行文件。

在什么场景下，需要考虑二进制兼容性？ 当你是一个shared library的维护者，你提供的库被其他团队、其他公司、其他社区所使用时，需要考虑。
这里面有两点：共享库的维护者，并且该库被不受你控制的团队所使用。  

如果只是开发团队内部特定场景下特定功能的库，使用范围较窄可以不用太在意二进制兼容性，发布新版本(修复Bug或者增加功能)，通知外部使用者重新编译，
使用即可。

修补Bug的patch应该做到二进制兼容，比如1.1.1应该和1.1.0，兼容，修复了一些bug，或者增加不影响二进制兼容的功能
如果新增功能与原有版本的二进制不兼容，那就应该发布到1.3.0版本上去。

c++语言：
发布方式：动态库 还是 静态库
如果需要hot fix，那么一定要发布为动态库，否则，在分布式系统中使用静态库更容易部署。

作为一个库来说，以什么方式暴露库的接口？一般来说有以下三种方式：
1. 以全局（含namespace级别）的函数为接口

2. 以class的non-virtual成员函数为接口,内部辅以 pimpl(pointer to implementation) 来提供具体实现。  <-- 推荐采用这种方式,可以确保二进制兼容性
并考虑多采用 non-member,non-firend function in namespace 作为接口，对外暴露的接口不要有虚函数,不要有数据成员

3. 以class的virtual函数为接口（interface）
调用：

回调： 客户端继承这个interface，然后将对象实例注册到库中，由库来回调自己
现代C++通过 boost:function + boost::bind 来更好的实现回调绑定

混合使用：混合调用和回调两种模式


* C++本身提供了四种标准异常： 只能通过 传值 或者 引用 来捕获, 传值捕获异常，会将异常对象拷贝两次，效率较低。
	       bad_alloc     --> operator new 不能分配足够内存时抛出
		   bad_cast      --> 当 dynamic_cast 针对一个引用reference操作失败时，抛出
		   bad_typeid    --> 当 dynamic_cast 对空指针进行操作时，抛出
		   bad_exception --> 用于 unexcepted 异常
		   
		   总结：优先使用传引用来传递异常

* 凡是本地的修改，全部做成patch的方式，独立保存起来，用于以后在有JIRA单的情况下，才推动到SVN库上面去。

* 对象构造要做到线程安全，要求在构造函数期间，不对外暴露this指针。
  作为class数据成员的mutex，只能用于同步本class的其他数据成员的读和写，它不能安全的保护析构.因为类成员的生命周期最多与对象一样长，而析构动作发生在对象销毁之时。

JIRA问题单号需要和SVN的提交编号绑定起来，那样在查找问题时，方便双向回溯查找。


### 配置文件实时更新读取 ###

要做到修改配置文件后，不用重启，立即生效的效果，要满足配置文件被外部修改时，程序要能够感应，这里的感应可分为主动感应和被动感应。
主动感应的思路可以是监控文件改动变化，如有变化，实时通知程序。
被动感应的思路是，每次获得配置信息（内含配置文件的修改时间）时，
手动检查下在配置文件的修改时间和上次读取到时间是否一致，如果不一致，则认为发生变化，重新读取一次。
一旦有变化，则意味着之前的配置信息可能存在不一致，因此，在读取前，要有一个reset的操作，将配置信息恢复到默认状态下。

## 具体问题的Tradeoff##

什么样的方案处理，才是最好的处理方式？在今天的讨论中，要处理两种失败的情况：

比如登录超时的后续处理

第一种做法：重载整个虚函数,其他的流程都是一样的，在 登录超时的分支里面，加上 重试登录的代码
一段时间后，改进了一下代码：因为登录错误要间隔一段时间，这里我复用了 登录超时的代码，将登录的
ask放入到 上述的超时分支处理里面，因为登录错误等待一段时间后也需要发送 重试登录的代码。但这里
就在一段只处理超时登录的代码里面，加入 登录失败超时重试的处理。从程序耦合性上来将，是不好的。

第二种做法：在基类虚函数中，再插入另外一个 虚函数，在派生类中，重写该虚函数，在这个里面统一做登录
操作

经过和何琨和泽波的讨论，发现 这种做法有混淆逻辑的嫌疑：可以做如下的改进：
1. 登录超时，不采用 插口虚函数的方式，而是承接原有的处理逻辑，在最后会往外发送超时通知的消息。
   可以通过订阅该消息来进行 逻辑上的解耦
2. 登录失败的重试，不应该复用登录超时的定时器，而是要自己写一个定时器，在回调函数中，去做超时的
   处理。 两种做法：原生的SetTimer和 基于原生的进一步的封装 CNotify 类。
   

### 常见问题解决方案 ###
### 字体配置 ###

项目工程的字体、颜色等属性信息，适应变化的解决方案：
比如说，这上面和下面显示的字体都是微软雅黑字体，现在来需求了：要求下面显示为微软雅黑加粗字体
方案一:
	每一个字体 都在配置文件里，配置好了，显示为微软雅黑加粗字体，那就新增一个配置字体。如果存在多种字体配置文件，
	那么每一个配置文件中都需要添加该新增字体。
	优点：现有获取字体逻辑不变，新增字体对应新增字体ID而已。
	缺点：每新增一个与现有字体样式风格差别很小的字体，都要在众多配置文件中新增。
	
方案二：
	默认字体就那么多，在不新增字体种类的情况下，提供一个 GetBoldFont(nFondId, BoldFont); 函数，用来
	将默认字体转换对应的加粗字体。
	优点:在不新增字体种类的情况下，增加灵活性，如果有其他类型的加粗字体需求，直接使用该函数即可。
	缺点:在获得加粗字体，需要使用特定的函数来实现。
	
	
	### 前端数据请求 ###
	
	### 界面数据请求 ###

当有一个界面，需要请求数据A，数据B。又有一个新界面，也要请求数据A，数据B，再来了一个新界面，也要请求数据A，数据B。
	 这个时候，如何去考虑扩展性和复用性？
	 总体思想：将各个界面重复性的代码逻辑抽离出来。考虑到数据请求的业务逻辑，各个界面，请求部分是一样的，区别在响应处理上，因此，可以考虑将请求部分提取出来，而响应部分，通过虚函数，留给各个界面去处理。
			   
	 具体实践：响应部分无需赘言，如何处理请求部分呢？有两个方向：
			   1. 将请求部分提取到基类中实现，将在基类中实现相关业务请求代码，这与基类的职责和整体流程控制关系不大，而且如果每个界面有数据C的请求，还会在基类继续添加请求函数，这会造成需求的变动影响了基类，不符合设计原则。
				   
			   2. 将请求部分提取到独立类去实现,实现如下的类结构：
					
					CDataReqObj()
					{	// 定义数据响应接口
						virtual void OnReturnCheckMsg(bool bOk) = 0;
					}
			   
					CWndA : CDataReqObj
					{
						CWndA()
						{
							m_pDataAsk.SetNotifyView(this);
						}
						CCommonDataReqObjImpl m_pDataAsk;
						
						// 实现数据响应接口
						virtual void OnReturnCheckMsg(bool bOk);
					}										

				   CCommonDataReqObjImpl
				   {	// 实现具体数据的请求和响应结果的分发
						CDataReqObj* m_pNotifyView;	// 记录通知的界面
						void SetNotifyView(CDataReqObj* p){m_pNotifyView = p;}											
						
						void ReqCommonData()
						{
							// ...
						}
						
						void OnReply()
						{
							if (m_pNotifyView)
							{
								m_pNotifyView->OnReturnCheckMsg();												
							}
						}
				   }								   

