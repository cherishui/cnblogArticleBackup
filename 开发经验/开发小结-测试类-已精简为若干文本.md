

测试只能决定软件质量的下限，而不能提高软件质量的上限。


测试代码一定不能不加保护的混合在发布产品中，如果是为了辅助调试，测试代码需要进行统一封装，
通过统一接口来访问。

自己开发的模块，要有自己的单元测试。如果是一些与后台同时升级的功能，在提测前，在自己这端要有集成测试。

不能将质量的保证交付测试，得由开发去主动推动，不能因为测试构造不出这一条分支路径，就不去考虑这种情况。
测试的依据是什么？产品提出的需求应该细化到什么程度？开发在具体工作中的边界在哪里？什么地方可以开发自己决定，什么地方要和产品确认？测试测的是
项目驱动型，或者是，问题解决型的学习效率是最高的


## Mock测试 ##

对于需要后台数据支持的业务开发，可以先在本地建立test_data数据文件，模拟正常情况下和异常情况下后台的返回情况，直接读取本地测试数据来进行前期的开发工作，等后台稳定后再联合调试。此种方法需要一个开关，打开时读取本地数据，关闭时读取网络数据。此开关的宏的含义是切换数据源，和内置的_DEBUG宏的含义不一样，因此要额外定义代表它明确含义的宏。

当开发涉及到两个程序见的交互时，比如A程序执行某项操作向B程序发出信号，而触发A程序发出信号的操作流程较为繁杂，那么可以在本地建立一个最简单的Mock程序，它的唯一功能就是模拟A程序向B程序发出信号。


单元测试，写一个system namespace头文件，其中声明 connect，read，write等普通函数，然后在.cpp文件中转发给对应的系统函数

```	
// SocketsOps.h
namespace sockets{

int connect(int sockfd, const struct sockaddr_in& addr);
}

// SocketsOps.cc
int sockets::connect(int sockfd, const struct sockaddr_in& addr)
{
retunr ::connect(sockfd, sockaddr_cast(&addr), sizeof(addr));
}

// 在运行单元测试时，将之前链接 SocketsOps.cc 改为链接到 MockSocketsOps.cc 这里，在这个间接层中，动动手脚即可。
// MockSocketsOps.cc
int sockets::connect(int sockfd, const struct sockaddr_in& addr)
{
errno = EAGAIN;
return -1;
}

```		 

## 测试案例梳理方法 ##

场景案例法，列举出具体每个操作的场景，从用户的角度出发，去看待软件应该具有的功能。操作，从简单到复杂，按照不同场景来描述，以下以港股通市场额度信息查询为例子
来描述案例
场景1. 打开界面进入时：
左侧的五档行情中的市场额度信息请求一次

场景2. 输入正确的股票后：
左侧的五档行情信息市场额度信息请求一次

场景3. 输入正确的股票后，再次点击港股通买入按钮：
左侧的五档行情界面中的市场额度信息请求一次

场景4. 港股通委托完成后：
左侧五档行情界面中的不请求市场额度信息

场景5. 从港股通委托界面的右侧持仓双击股票时，会传递股票到五档行情界面和委托界面，
在此场景下,会查询两次市场额度信息,相当于连续进入2次 "场景2"

场景6：有行情右键或者按键精灵221进入港股通买卖界面，会查询两次市场额度信息
此种场景下，相当于 "场景1" + "场景2" 的组合

当通过这种场景描述法提出了修改参考，准备征求各方意见时，如果没有人回应，那么应该主动通过qq去催告一下相关的人员。

测试人员和开发人员对于测试案例的理解上，存在信息不对称性。在测试案例完备性上，开发人员有天然的优势，因此，我觉的，可以这样来从开发的角度来，按每一个分支流程来反推出相关的测试案例，从测试人员的角度来看，执行什么样的操作，会触发哪一条业务逻辑路径？从开发人员的角度来看，这一条业务路径，往上对应哪一条测试动作。特别是在旧代码上修复bug，如果不显著注意到改Bug的一些副作用或者一些额外的业务路径，非常有可能造成改一个Bug，产生两个Bug，继续改，继续产生新的Bug，用打补丁的方式，是无法彻底解决问题的。需要从全局的观点去看待Bug产生的根源，

写Bug的单号和内容的匹配性和一致性，怎么强调都不为过。有单才提交，没单绝对、绝对不提交。   
工作流程要规范，写备注，或者解析Bug出现的原因时，结论先给出，然后空出一行，下面给出论证的详细过程。


## 安全编码 ##
1.1 一切外部数据都应该视为不可信数据。对于可枚举的输入数据，应该使用白名单的方式进行检查，若输入内容不符合格式要求，则拒绝用户请求
常见的数据类型有：email地址（任意数字字母和下划线的组合+@+域名），用户名(3-10位，数字、字母以及相互组合)，密码（数字、字母、符号，三种必须都有，8位以上）
	  
1.2  用户设置的密码不能与用户名相同，修改密码时，新旧密码不能相同
	
1.3 防范日志中输出敏感信息,对于程序在运行过程中的日志记录，应避免输出用户敏感信息和系统运行状态等数据.
	
1.4 如果接口错误返回信息返回了相关数据库的错误，需要采用更为通用的错误提示方式，而不是暴露相关后台数据信息。
