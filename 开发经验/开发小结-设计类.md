本文主要汇总了自己在软件设计方面的一些经验总结。

## 总体设计 ##

多与人讨论，不管讨论的对象是老手、还是小白，

 对于一些基础组件的重构改进，在自己做完相关设计后，务必要请组内其他人一起评审下，不要以自我为中心，以为自己写的接口就是完美的。
人无完人，多一些来自其他同事的视角，多一些角度去审查接口以及具体实现，于人于己都是大有益处的。

我负责的某个基类代码，其中有些接口以及内部实现写的不合理，外部使用很别扭，但因为前期就自己在使用，别扭就别扭的用了。随着时间的流逝，该类被越来越多的人使用，吐嘈声不断，自己有过重构接口的想法和方案，但碍于改动牵涉到的面较大，关于这点也就没下文了。

## UI设计 ##

UI显示流程，一般来说UI显示的数据来自后台，在触发刷新动作之后，在“当前界面的数据是否要清空”这个问题上，有几种观点：
			  
清空界面数据： 优点每次不会看到旧数据，缺点是当网络不好时，显示界面会空白。

不清空界面数据：优点是在网络尚未返回数据时，用户体验好。缺点是，看到的数据是上一次的旧数据。

具体采用哪种措施，个人觉的取决于当前数据对用户的重要程度以及更新频率，如果很重要并且数据频繁更新，那最好在请求后清空界面数据。如果不是那么重要，而且更新频率不高，那么不清空界面数据带来的体验较好。从一致性角度上来看，请求前先把界面数据清空是较好的流程。

对于一个界面来说，进入和退出的处理，最好要有相互呼应的地方。怎么理解呢？比如说，打开的时候有清空的动作，那么退出也要有清空的动作。打开的时候有申请资源，发送请求的动作，在退出的时候，也要有释放资源和取消请求的动作，启动时有初始化的动作，那么退出时，就要有卸载的动作。

一个正常界面展示的流程大致如下：

1. 初始化界面上面的控件的参数属性，比如设置小数位数，设置字体等等
2. 将界面上所有的控件状态置为清空状态
3. 然后根据外部输入的参数来有针对性的设置

### 最小知识原则 ###

一个不满足最小知识原则的例子：

    m_ActionCode.SetWindowText(strCompanyBehaviorcode);

在这条语句中，开发人员需要了解`m_ActionCode`和`strCompanyBehaviorcode`的具体含义，然后再判断该赋值语句是否正确，这增加了对阅读者知识的要求，为了降低阅读者的知识负担，在控件和它的内容之间要建立核心词汇的联系，不能一种含义有两种表达方式。上面的例子可以改善为：

    m_ActionCodeEdit.SetWindowText(strActionCode);

这样，光从字面上，就可以得知这个赋值关系应该是正确的，将动作代码赋值到动作代码编辑框，也方便后续的检查。

## 解决方案设计 ##

任何一个需求或者功能的实现，都可以至少定出三个方案，在开始编码之前，要分析各个方案在实现基本功能需求之外，
在其他细节地方有不同的优缺点？在满足基本功能的情况下，选择哪一种方案较好？如果涉及到的模块较多，可以先提出各种方案，再交由团队一起来讨论，看看在这种场景下，使用哪种方案较好。

单独提出一个方案，没有对比方案，不具备可比较性和优缺点分析。对于每一个问题，至少可以给出2到3个方案。在重新设计时，不要被已有的实现所束缚住。

脑子里面首先想出来的方案，往往不是最佳的，肯定有改进的空间。
每一个设计方案，首先都有它的整体的设计思路，随后的铺陈展开，都围绕这个整体思路来做。

在想第二个设计方案时，不要让已有的实现细节所束缚住，假设这个模块是刚开始做的，从0开始，你会怎么去组织和设计各种信息。

将各个模块所使用到的公用数据集中汇总到CGlobal类中，在特定条件改变时，只需要更新此类中的内容。其他依赖该数据的模块，在需要用到的时候，主动去获取即可。这种方式，将易于变化的状态封装在一起。

能够动态计算的内容，不需要额外加一个变量来保存，提供接口函数，在每次获取时，发消息去获取或者动态计算获得。
类似于这样的：
```
void GetMainRect(CRect& rect)
{
	CMainWnd* pRoot = dynamic_cast<CMainWnd*>(AfxGetMainWnd());
	if (pRoot)
	{
		pRoot->SendMessage(WM_GET_MAIN_RECT, 0, (LPARAM)&rect);
	}
}
```
这种方式，相当于公用变量的状态 不存在,或者说，存在在每次调用的临时变量中，调用完就释放了。
 
对于枚举类型和字符类型的相互转换，如果枚举类型只定义了4种，每一种有对应的数值，ELoginType eLoginType = (ELoginType)m_cTemp;
这种显示的强制转换，明显的是多对一的情况，不符合语义，建议使用函数来转换

enum ELoginType
{
	LOGIN_NONE          = '0',  // 未定义
	LOGIN_CAPITAL       = 'I',  // 资金账号
	LOGIN_SZ_A          = '2',  // 深圳A股
	LOGIN_SH_A          = '1',  // 上海A股
	LOGIN_USER_CODE     = 'J',  // 客户代码
	LOGIN_SZ_B          = '4',  // 深圳B股
	LOGIN_SH_B          = '3',  // 上海B股
	LOGIN_UFX           = 'M',  // UFX账号
	LOGIN_TRAINING      = 'D',  // 培训，投顾服务账号
};

ELoginType eLoginType = (ELoginType)88; // 最后的结果 eLoginType 的值是88，它不在枚举定义中。这是一个潜在的坑，
在以后的实践中，一定要注意。

枚举可以转换为整形，但整形不能简单的转换为枚举，要保证 google：int to enum c++ 搜索关键字
也可以这样来做：
用switch来进行整形到枚举的转换，对于不在枚举值中的转换，报错提示，统一用默认类型来转换。
		

### 高内聚低耦合 ###
高内聚：
 什么样的功能需要高内聚在一起，在今天上午的讨论中，比如断线重连提示框的策略控制和它本身的实现。
 就这两个功能点来说，断线重连提示框本身作为一个较独立的功能，肯定是要在其他文件中独立实现的。
 而它作为一个组件，被第三方使用时，或者说它自身提供给外部的功能接口有哪些？这里面就有道道了。
 
 自己的理解，它应该对外提供什么样的功能，要有外部使用者来定义。而这些功能的粒度问题，就要由
 具体场景来定义。
 如果外部使用者只需要弹出一个框，框的大小位置是固定的，只有其中内容不同而已，外部使用者目前来说
 只有一个，而这个框目前也只为这个使用者服务，那么，框对外提供的接口，不应该暴露太多细节函数的调用.
 比如说，创建一个对话框 ，那么创建的时机可以是在初始化时创建，也可以是在首次使用时再创建，这都没问题。
 创建时，使用的函数,按照上面的最少知识原则：应该只需要这样既可：
 
 这是不好的例子：使用者需要关注对话框对外提供的众多函数以及相互之间的组合
 void CJyReConnectMananger::ShowReConnectDlg(EJyReConnectStatus eReConnectStatus)
{
	if (NULL == m_pJyReConnectDlg)
	{
		m_pJyReConnectDlg = new CJyReConnectDlg(AfxGetMainWnd());
		if (m_pJyReConnectDlg)
		{
			m_pJyReConnectDlg->Create(CJyReConnectDlg::IDD, AfxGetMainWnd());
			m_pJyReConnectDlg->SetCaptionHeight(CAPTIONHIGH);
			m_pJyReConnectDlg->SetLogo();
		}
	}

	if (m_pJyReConnectDlg)
	{
		m_pJyReConnectDlg->SetContent(eReConnectStatus);
		m_pJyReConnectDlg->CenterWindow();
		m_pJyReConnectDlg->SetWindowPos(&CWnd::wndTopMost, 0,0,0,0,SWP_SHOWWINDOW|SWP_NOMOVE|SWP_NOSIZE);
	}
}

可以这样来修改：
	if (NULL == m_pJyReConnectDlg)
	{
		m_pJyReConnectDlg = CJyReConnectDlg::CreateReConnectDlg();
	}

	if (m_pJyReConnectDlg)
	{
		m_pJyReConnectDlg->SetContent(eReConnectStatus);
	}
	
	对外只需要暴露两个函数，一个创建，一个设置内容，一个销毁。对外部使用者来说，要求它有最少知识原则。

这种修改适用于外部使用者不关注功能提供者的一些具体细节信息，如果是那些被很多使用者用到的公共
控件类，那这种基本功能的封装就不能满足多种多样的场景，就要提供独立的功能函数。
	
最少知识原则: 每个类负责的职责清晰明了，使类可以高度内聚，降低类与类之间的耦合。
基础组件提供的功能，高层直接使用的话，需要关注较多的细节，那么，此处需要一个中间层，来封装组合一些细节函数，
对外提供较为高级的功能，这一点工作是需要做的。问题在于，这个中间层放置在哪里？
	1. 在基础组件A中实现这些中间层较高级功能的封装
	
	2. 通过中间组件，此组件不仅仅依赖基础组件A，还要依赖一些其他组件B、C，一起来完成一个特定功能。
	
	如果中间层用到的功能，不需要依赖其他一些组件（比如说，账号信息、锁定状态等），那推荐使用第一种方式实现，
	在基础组件中，不仅仅提供基础功能，也提供一些基础功能的相关组合。
	
	如果外部使用组件A时，需要依赖于一些其他组件B和C，如果这种功能各个界面都用到，那就适合放在中间件来完成，

高内聚的另一种角度的理解：
相同语意的语句要内聚到一起。具体表现为一组相关的数据类型定义，应该聚合在一起，方便阅读理解。比如和登录相关的，登录类型（深A、资金账号）和认证类型

代码被阅读的次数要远远大于它被修改的次数，因此，代码可读性决定了可维护性，代码定义的关联性（相关代码定义和对应辅助函数）要大于分散性。相互关联的定义以及使用，应该或者说必须放在一起。

# UI界面复用 #

复用和耦合是一对相互矛盾体，在开发实践中，如何权衡什么时候用复用，什么时候用耦合，以下面例子为引入：
现在有一个对话框，上面有确定按钮和取消按钮,这两个按钮不是同时出现的，点击确定，对外传递确定的处理消息；点击取消，进行取消的处理消息。由于是非模态的，不好通过返回值来处理。由于这两个按钮不是同时出现的，因此有一个状态变量来控制当前界面显示的是确定还是取消。

我之前的做法是： 在这一个对话框上面放两个按钮，通过传入状态变量实现一次只显示一个，外部在使用时，有两种方式获得该框的退出状态，一是消息，二是获得该框内部的状态变量。当该框被多个地方使用时，采用方法二的做法就会越写越复杂。可以通过消息的方式来分离UI和事件。
但是，更好的做法是，将这两个不同目的的对话框区分开，一个确认对话框就只有确认的功能，一个取消对话框就只有取消的功能，这样，在UI层和业务层就明确区分，外部在使用时，无需考虑太多的内部状态，确定就是确定，取消就是取消。

基于此的基础上,再进一步深入，什么时候需要复用UI？
我自己的思考：
1. 在界面布局有新的功能性的增加(例如增加一个checkbox框，增加一个取消按钮,改变原有UI元素的属性(位置和大小改变)的情况下，不能复用
2. 在界面布局有非功能性的改变（比如，隐藏某些控件，禁用某些控件），能够复用

对现有程序逻辑的思考和改进：
一个对话框，需要适配两种不同的策略，这两种策略显示的元素是一样的，点击的操作和后续的操作完全时一样，不同的是提示文字的内容和颜色，还有按钮的禁用状态

三种做法
1. 公用一个对话框，通过传入不同的参数类型，在对话框初始化函数里面做不同类型界面的初始化
2. 把两种策略的对话框相同部分抽离出一个父对话框，然后基于此父对话框，派生两个子对话框，父对话框提供一个UI界面的初始化虚函数，由
各个子对话框去完成各自策略不同部分的UI初始化  <--- 通过继承的方法来实现复用
3. 通过组合的方式来实现复用, 先对这两个策略，实现完全不同的对话框Dlg1和Dlg2，各自处理各自的业务. 然后由一个对外对话框DlgOuter包含着两个对话框Dlg1和Dlg2。

复用的层次理解：
函数级别的复用 --> 通用工具类（获取路径、获取本机信息、加解密、编解码）函数 
类级别的复用   --> 通用对话框类，通用功能类（下载文件，http请求等）
模块(组件)级别的复用 ---> 提供给外部团队使用
子系统的复用 		--> 用户中心、订单中心、面板中心等等

## 颜色的复用 ##

在程序中使用的颜色，肯定不会直接写死固定数值，而是用映射来关联关系，颜色ID <--> 颜色数值，只要是用在不同地方的颜色，就算是相同的颜色数值，也要用不一样的颜色ID，防止以后需求颜色变动时，影响了其他地方的颜色。

为了减少颜色的适配工作量，同时为以后的切换颜色方案打好基础，开发给设计就需要提供颜色取值范围，不能让设计无休止的提各种不同的颜色，例如，每一类颜色只提供可选的10左右的ID段范围，可以有多类(12类)颜色，设计提供的总的颜色数值总量控制，具体数值可以自定。

## 消息设计 ##

消息宏的定义要全局唯一，不管是在哪种消息处理机制下，不管是在不同进程、不同机器下，消息的定义唯一可避免不同模块定义了相同数值的消息，但不同模块的入参
 不一样，其他方在使用时，有可能广播消息而导致出错。要做成全局唯一，最佳实践是在同一层级目录下，定义全局消息，事先定义好各个业务的消息起始段和结束段。

对于消息全局定义唯一的思考：第一个是：这样做，有什么好处？ 第二个是：不这样做，有什么坏处?
思路一：在其他组件需要新定义消息或者要使用已有定义的消息时，能够到明确的地方去定义和使用

思路二: 消息所代表的数据以及使用该消息时的入参说明对系统中各个组件保持一致。不会说 
```
组件A定义  #define MSG_A 100 // 干A事情 传参类型: int 
组件B定义  #define MSG_B 100 // 干B事情 传参类型: string

那当组件C给组件A，和组件B发消息时，需要发送两条，而且每个消息的参数还不一致，这样，在具体的消息处理时，就很容易造成潜在的崩溃

```

每一种消息的定义要清楚明确，比如显示特定用户信息，清除界面显示这两个功能，第一个功能可以通过 WM_SHOW_INFO 附带一个用户标识过去完成。第二个功能，有两种做法：

* 也使用WM_SHOW_INFO，传空的用户标识过去，在接收端判断，如果为空，就清除已显示内容。
* 单独定义清空界面显示消息，WM_CLEAR_INFO 

这两种做法，推荐使用第二种，它符合消息功能的唯一性。

对于多层消息传递，当前层只需要知道直接上级的窗口，通知也只需要通知到直接上级，不能跨层级的通知，那样会破坏分层的目的的
	   
消息的命名规范，与现有消息保持一致,如果不一致，则需要修改使其一致，同时，本次修改消息名称，作为一次单独提交来声明

消息的使用方法、入参说明以及正常的使用范例，需要随着消息的定义一同清晰明确的给出

每个独立的消息的定义以及使用，需要有明确的入参要求和参数传递要求，同一功能的消息（包括入参、出餐、返回值的含义和格式等），只需要定义一个即可
如果有其他的业务需求，实现的功能是一样的，但是由于某种原因，无法保证相关的入参格式，比如说 测试工具发送过来的消息,入参格式不一样，对于这种情况下的消息，功能需求是一样的，但是入参不一样（一个传了指针过来，一个没有传），同一个消息，不同场景下发送的参数不同，很容易出错的。
应对方法：具体功能，但是入参不一样，这种，需要在新建一个消息，做对应功能的定义，不能混用消息。


对于消息的定义和使用，老生常谈了，一种消息附带的参数，一定要是能够确定的，绝对不能是类似于这种

```
	 struct NMClickNum
	 {
		CStock m_stk;
		vector<CString> m_vInfo;
	 };
	 
	 类似于这种消息，是有隐患的，特别是当该消息带着这样的参数，在不同界面上使用时，比如A界面vector里面
	 塞3个数据，B界面塞5个数据。在消息接收端，它一定要首先判断消息的个数是否符合要求，但即使是符合要求，
	 也不能确保收到的消息就一定是想要的，这种带不定长数据的消息发送到多个界面的做法，是非常危险的，谨记，
	 谨记。
	 较好的工程实践是：业务层面的消息的目的性要唯一，不能造一个通用层面的消息，携带各种数据，在各种组件
	 之间穿梭。而是，针对特定的业务和界面，定义特定的消息，比如说A界面需要3个数据，B界面需要另外3个数据，
	 C组件产生这3个数据是A界面需要的，D组件产生的3个数据是B界面需要的，在定义消息时，A-C之间定义一个消息，
	 D-B之间定义另一个消息，不同消息携带的参数
```

### 消息的组织 ###

1. 现有工程中的消息流转使用：
  1.1 Windows消息（包括系统消息和自定义消息）
	  发送方式：直接使用SendMessage或者PostMessage来发送
	  适用范围：	父窗体是基于对象树对象的窗体，子控件是Windows窗体,继承于CWnd，CEdit等基础控件，
				他们之间的交互消息定义，需要定义在这里
		
  1.2 消息对象树消息
	  发送方式：使用 SendDown 或者 BroadcastDown 来发送消息
	  适用范围：大的交易控件下，内部不同子窗体之间的消息交互,比如，左、中、右三个窗体，中间的窗体需要发到右侧
				或者是右侧的窗体需要传递股票到左侧
	  
  1.3 订阅发布消息
	   发送方式：通过 PublishNotify 广播消息或者 SendToObserver 发送给特定观察者 来实现
 
 在一个系统中，消息的组织按照现有工程来理解的话，这样来布局比较好。
 
 通用模块				交易模块					行情模块
	---Windows消息		---Windows消息			---Windows消息
	---对象树消息			---对象树消息			    ---对象树消息
	---订阅通知消息		---订阅通知消息			---订阅通知消息
					 
比如，基础控件通知父窗口的消息，应该放到通用模块中的Windows消息中去
	 交易模块使用的窗口之间的价格传递，应该放到交易模块的对象树消息中去
	 交易模块中的数据管理单例和交易界面的通知，应该放到交易模块的订阅通知消息中去
	 
	 
4. 消息的功能的定义
 举个例子：比如有左侧有行情报价版，中间有股票。这个消息既要实现传递有效股票，显示对应股票的行情信息，又要有清空已有显示信息的功能
 有两种做法：
 1. 定义两个消息，一个为只切换股票展示对应行情信息，另一个用作界面数据复位的功能
	优点：消息的接收方处理起来直接  缺点：发送方要根据不同的条件发送不同的消息
	
 2. 定义一个消息:转为切换股票来实现，如果股票有效，则显示股票行情信息，如果股票为空，则清空界面已有信息

